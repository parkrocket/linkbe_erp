const express = require('express');
const User = require('../models/userModel');
const Gtw = require('../models/gtwModel');
const Vca = require('../models/vacationModel');
const moment = require('moment');
const router = express.Router();
const slackApp = require('../utils/slack');
const { WebClient } = require('@slack/web-api');
const requestIp = require('request-ip');
const crypto = require('crypto');
const { sendSlackMessage } = require('../utils/slack');
const { google } = require('googleapis');

const algorithm = 'aes-256-cbc';
const secretKey = 'linkbeflatformlinkbeflatformlink'; // 32Î∞îÏù¥Ìä∏ ÌÇ§
const ivLength = 16; // AES Î∏îÎ°ù ÌÅ¨Í∏∞

const oAuth2Client = new google.auth.OAuth2(process.env.GOOGLE_C_ID, process.env.GOOGLE_S_ID, process.env.GOOGLE_CALLBACK_URL);

const encrypt = (text) => {
    const iv = crypto.randomBytes(ivLength); // ÏïîÌò∏ÌôîÎßàÎã§ Îã§Î•∏ IV ÏÇ¨Ïö©
    const cipher = crypto.createCipheriv(algorithm, Buffer.from(secretKey), iv);
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    return iv.toString('hex') + ':' + encrypted;
};

const decrypt = (text) => {
    const textParts = text.split(':');
    const iv = Buffer.from(textParts.shift(), 'hex');
    const encryptedText = Buffer.from(textParts.join(':'), 'hex');
    const decipher = crypto.createDecipheriv(algorithm, Buffer.from(secretKey), iv);
    let decrypted = decipher.update(encryptedText, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    return decrypted;
};

const token = process.env.SLACK_BOT_TOKEN;
const client = new WebClient(token);

function checkToken(req, res, next) {
    if (fs.existsSync(TOKEN_PATH)) {
        const token = JSON.parse(fs.readFileSync(TOKEN_PATH, 'utf8'));
        oAuth2Client.setCredentials(token);

        // ÌÜ†ÌÅ∞ Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
        oAuth2Client.getAccessToken((err, token) => {
            if (err || !token) {
                console.log('No valid token found, redirecting to auth');
                return res.redirect('/api/slack/auth');
            }
            next();
        });
    } else {
        console.log('No token found, redirecting to auth');
        return res.redirect('/api/slack/auth');
    }
}

// Ïù∏Ï¶ù URL ÏÉùÏÑ± (ÏµúÏ¥à Ïù∏Ï¶ùÏùÑ ÏúÑÌï¥ ÌïúÎ≤à ÏàòÌñâ)
router.get('/auth', (req, res) => {
    const authUrl = oAuth2Client.generateAuthUrl({
        access_type: 'offline',
        scope: ['https://www.googleapis.com/auth/calendar'],
    });
    res.redirect(authUrl);
});

// Ïù∏Ï¶ù ÌõÑ ÌÜ†ÌÅ∞ Ï†ÄÏû•
router.get('/oauth2callback', (req, res) => {
    console.log(req.query.code);

    const code = req.query.code;
    oAuth2Client.getToken(code, async (err, token) => {
        if (err) return res.status(400).send('Error retrieving access token');
        oAuth2Client.setCredentials(token);

        // ÌÜ†ÌÅ∞ÏùÑ ÏïàÏ†ÑÌïú Í≥≥Ïóê Ï†ÄÏû•ÌïòÏÑ∏Ïöî (Ïòà: Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§)
        res.send('Authentication successful! You can close this tab.');
    });
});

router.post('/events', async (req, res) => {
    await slackApp.requestListener()(req, res);
});

const publishHomeView = async (userId, user, gtw, myGtw, date, encryptedUserId) => {
    const userName = user.user_name;
    const gtwStatus = user.gtw_status;
    const gtwLocation = user.gtw_location;

    let actionBlocks = [];
    // Îã§Î•∏ ÏÇ¨ÎûåÎì§Ïùò Ï∂úÌá¥Í∑º Ï†ïÎ≥¥ ÌëúÏãú
    if (gtw.length > 0) {
        let gtwText = 'Í∑ºÎ¨¥Ï§ë / Ï∂úÍ∑ºÏãúÍ∞Ñ\n\n';
        gtw.forEach((entry) => {
            let locationIcon = entry.location === 'office' ? 'üè¢' : 'üè†';
            let formattedStartTime = moment(entry.start_time).format('HHÏãú mmÎ∂Ñ ssÏ¥à');
            gtwText += `${locationIcon} ${entry.user_name} : ${formattedStartTime}\n`;
        });

        actionBlocks.push(
            {
                type: 'section',
                text: {
                    type: 'mrkdwn',
                    text: gtwText,
                },
            },
            {
                type: 'divider',
            }
        );
    }

    if (myGtw.length > 0) {
        let formattedStartTime = moment(myGtw[0].start_time).format('HHÏãú mmÎ∂Ñ ssÏ¥à');
        let formattedEndTime;
        let endTimeLabel;

        if (myGtw[0].end_time) {
            // Ïã§Ï†ú Ìá¥Í∑º ÏãúÍ∞ÑÏù¥ ÏûàÎäî Í≤ΩÏö∞
            formattedEndTime = moment(myGtw[0].end_time).format('HHÏãú mmÎ∂Ñ ssÏ¥à');
            endTimeLabel = 'Ìá¥Í∑º ÏãúÍ∞Ñ';
        } else {
            // Ìá¥Í∑º ÏòàÏÉÅ ÏãúÍ∞ÑÏùÑ Í≥ÑÏÇ∞
            let estimatedEndTime = moment(myGtw[0].start_time).add(9, 'hours').format('HHÏãú mmÎ∂Ñ ssÏ¥à');
            formattedEndTime = estimatedEndTime;
            endTimeLabel = 'Ìá¥Í∑º ÏòàÏÉÅÏãúÍ∞Ñ';
        }

        actionBlocks.push(
            {
                type: 'section',
                text: {
                    type: 'mrkdwn',
                    text: `ÎÇòÏùò Í∑ºÎ¨¥ ÏÉÅÌÉú:\n\nÏ∂úÍ∑º ÏãúÍ∞Ñ: ${formattedStartTime}\n${endTimeLabel}: ${formattedEndTime}`,
                },
            },
            {
                type: 'divider',
            }
        );
    }
    if (gtwStatus === 0) {
        actionBlocks.push({
            type: 'section',
            text: {
                type: 'mrkdwn',
                text: 'Ï∂úÍ∑º ÏòµÏÖòÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî:',
            },
        });
        actionBlocks.push({
            type: 'actions',
            elements: [
                {
                    type: 'button',
                    text: {
                        type: 'plain_text',
                        text: 'Ï∂úÍ∑ºÌïòÍ∏∞',
                    },
                    url: `https://hibye.kr/gtw?userId=${encryptedUserId}&type=gtw&platform=slack&slackuser=${userId}`,
                    action_id: 'clock_in',
                },
                {
                    type: 'button',
                    text: {
                        type: 'plain_text',
                        text: 'Ïû¨ÌÉùÏ∂úÍ∑ºÌïòÍ∏∞',
                    },
                    url: `https://hibye.kr/gtw?userId=${encryptedUserId}&type=remote_gtw&platform=slack&slackuser=${userId}`,
                    action_id: 'remote_clock_in',
                },
            ],
        });
    } else if (gtwStatus === 1) {
        let url;

        if (gtwLocation === 'office') {
            url = `https://hibye.kr/gtw?userId=${encryptedUserId}&type=go&platform=slack&slackuser=${userId}`;
        } else {
            url = `https://hibye.kr/gtw?userId=${encryptedUserId}&type=remote_go&platform=slack&slackuser=${userId}`;
        }

        actionBlocks.push({
            type: 'section',
            text: {
                type: 'mrkdwn',
                text: 'Ìá¥Í∑ºÌïòÍ∏∞Î•º ÎàåÎü¨Ï£ºÏÑ∏Ïöî:',
            },
            accessory: {
                type: 'button',
                text: {
                    type: 'plain_text',
                    text: 'Ìá¥Í∑ºÌïòÍ∏∞',
                },
                url: url,
                action_id: 'clock_out',
            },
        });
    } else if (gtwStatus === 2) {
        actionBlocks.push({
            type: 'section',
            text: {
                type: 'mrkdwn',
                text: 'Ïò§Îäò ÌïòÎ£® ÏàòÍ≥†ÌïòÏÖ®ÏäµÎãàÎã§!',
            },
        });
    }

    // ÏÉàÎ°úÏö¥ Î≤ÑÌäºÏùÑ Ï∂îÍ∞ÄÌï©ÎãàÎã§.
    actionBlocks.push({
        type: 'section',
        text: {
            type: 'mrkdwn',
            text: 'üèñÔ∏è Ìú¥Í∞Ä Î∞è Ïó∞Ï∞®Ïã†Ï≤≠',
        },
    });

    actionBlocks.push({
        type: 'actions',
        elements: [
            {
                type: 'button',
                text: {
                    type: 'plain_text',
                    text: 'Ïã†Ï≤≠ÌïòÍ∏∞',
                    emoji: true,
                },
                action_id: 'open_modal',
            },
        ],
    });

    const blocks = [
        {
            type: 'context',
            elements: [
                {
                    type: 'plain_text',
                    text: `üéâ ${date}Ïùº ÏûÖÎãàÎã§. ${userName}Îãò!`,
                    emoji: true,
                },
            ],
        },
        {
            type: 'divider',
        },
        ...actionBlocks,
    ];

    const view = {
        type: 'home',
        callback_id: 'home_view',
        blocks: blocks,
    };

    try {
        await client.views.publish({
            user_id: userId,
            view: view,
        });
    } catch (error) {
        console.error('Error publishing view:', error);
    }
};

// Î™®Îã¨ÏùÑ ÎùÑÏö∞Îäî Ìï®Ïàò
const openModal = async (trigger_id) => {
    try {
        await client.views.open({
            trigger_id: trigger_id,
            view: {
                type: 'modal',
                callback_id: 'modal-identifier',
                title: {
                    type: 'plain_text',
                    text: 'Ìú¥Í∞Ä Î∞è Ïó∞Ï∞®Ïã†Ï≤≠',
                },
                blocks: [
                    {
                        type: 'section',
                        text: {
                            type: 'mrkdwn',
                            text: 'Ìú¥Í∞Ä Î∞è Ïó∞Ï∞®Î•º Ïã†Ï≤≠Ìï¥Ï£ºÏÑ∏Ïöî.',
                        },
                    },
                    {
                        type: 'input',
                        block_id: 'input_c',
                        label: {
                            type: 'plain_text',
                            text: 'Ìú¥Í∞Ä Î∞è Ïó∞Ï∞® ÏÑ†ÌÉùÌïòÏÑ∏Ïöî',
                        },
                        element: {
                            type: 'static_select',
                            action_id: 'select_input',
                            placeholder: {
                                type: 'plain_text',
                                text: 'Ìú¥Í∞Ä Î∞è Ïó∞Ï∞® ÏÑ†ÌÉùÌïòÏÑ∏Ïöî',
                            },
                            options: [
                                {
                                    text: {
                                        type: 'plain_text',
                                        text: 'Ïû¨ÌÉù',
                                    },
                                    value: 'home',
                                },
                                {
                                    text: {
                                        type: 'plain_text',
                                        text: 'Î∞òÏ∞®',
                                    },
                                    value: 'half',
                                },
                                {
                                    text: {
                                        type: 'plain_text',
                                        text: 'Ïó∞Ï∞®',
                                    },
                                    value: 'day',
                                },
                                {
                                    text: {
                                        type: 'plain_text',
                                        text: 'Ìú¥Í∞Ä',
                                    },
                                    value: 'vacation',
                                },
                            ],
                        },
                    },
                    {
                        type: 'input',
                        block_id: 'input_date',
                        label: {
                            type: 'plain_text',
                            text: 'ÎÇ†ÏßúÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî',
                        },
                        element: {
                            type: 'datepicker',
                            action_id: 'datepicker_input',
                            placeholder: {
                                type: 'plain_text',
                                text: 'ÎÇ†Ïßú ÏÑ†ÌÉù',
                            },
                        },
                    },
                ],
                submit: {
                    type: 'plain_text',
                    text: 'Ï†úÏ∂ú',
                },
            },
        });
    } catch (error) {
        console.error('Error opening modal:', error);
    }
};

router.post('/home', async (req, res) => {
    const { type, challenge, event } = req.body;

    if (type === 'url_verification') {
        return res.status(200).send({ challenge });
    }

    if (type === 'event_callback' && event.type === 'app_home_opened') {
        const userId = event.user;

        try {
            const userInfo = await client.users.info({ user: userId });

            if (!userInfo.ok) {
                console.error('User info error:', userInfo.error);
                return res.status(500).send('User info error');
            }

            const userEmail = userInfo.user.profile.email;
            const date = moment().format('YYYY-MM-DD');
            const encryptedUserId = encrypt(`${date}|${userEmail}`);

            const user = await User.findByEmailAsync(userEmail);
            if (!user) {
                console.log('User not found:', userEmail);
                return res.status(404).json({ refreshSuccess: false, error: 'User not found' });
            }

            const gtw = await Gtw.findByGtwAllAsync(date);
            const myGtw = await Gtw.findByGtwAsync(user.user_id, date);

            await publishHomeView(userId, user, gtw, myGtw, date, encryptedUserId);

            res.status(200).send();
        } catch (error) {
            console.error('Error fetching user info:', error);
            res.status(500).send('Error fetching user info');
        }
    } else {
        res.status(200).send();
    }
});

router.get('/gtwCheck', async (req, res) => {
    const { userId, type, platform, slackuser } = req.query;
    const date = moment().format('YYYY-MM-DD');
    const dateNow = moment().format('HHÏãúmmÎ∂ÑssÏ¥à');

    let location;
    if (type === 'gtw' || type === 'go') location = 'office';
    if (type === 'remote_gtw' || type === 'remote_go') location = 'home';

    let ip;
    let errorM = '';

    if (process.env.NODE_ENV === 'development') {
        ip = process.env.DEV_IP;
    } else {
        ip = req.clientIp.includes('::ffff:') ? req.clientIp.split('::ffff:')[1] : req.clientIp;
    }

    try {
        const decryptedUserId = decrypt(userId);
        const parts = decryptedUserId.split('|');

        if (date !== parts[0]) {
            return res.json({ message: 'ÏûòÎ™ªÎêú Ï†ëÍ∑ºÏûÖÎãàÎã§.', windowClose: false });
        }

        if ((type === 'gtw' || type === 'go') && process.env.COMPANY_IP !== ip) {
            console.log('ip', ip);

            return res.json({ message: 'ipÍ∞Ä ÏùºÏπòÌïòÏßÄ ÏïäÏäµÎãàÎã§.', windowClose: false });
        }

        try {
            const gtw = await Gtw.findByGtwAsync(parts[1], date);
            if (type === 'gtw' && gtw.length > 0) {
                if (gtw[0].end_time === null) {
                    errorM = 'Ïù¥ÎØ∏ Ï∂úÍ∑ºÏ§ëÏûÖÎãàÎã§.';
                } else {
                    errorM = 'Ïù¥ÎØ∏ Ìá¥Í∑ºÌïòÏÖ®ÏäµÎãàÎã§. ÎÇ¥ÏùºÎèÑ ÌôîÏù¥ÌåÖ.';
                }
                return res.json({ message: errorM, windowClose: false });
            }

            await Gtw.createAsync(parts[1], type, date, ip, platform);

            const userInfo = await client.users.info({ user: slackuser });
            if (userInfo.ok) {
                const userEmail = userInfo.user.profile.email;
                const encryptedUserId = encrypt(`${date}|${userEmail}`);

                try {
                    const user = await User.findByEmailAsync(userEmail);
                    if (!user) {
                        console.log('User not found:', userEmail);
                        return res.status(404).json({ refreshSuccess: false, error: 'User not found' });
                    }

                    try {
                        const gtwAll = await Gtw.findByGtwAllAsync(date);
                        const myGtw = await Gtw.findByGtwAsync(user.user_id, date);

                        await publishHomeView(slackuser, user, gtwAll, myGtw, date, encryptedUserId);

                        const message =
                            type === 'gtw' || type === 'remote_gtw'
                                ? `${user.user_name}ÎãòÏù¥ ${dateNow}Ïóê Ï∂úÍ∑ºÌïòÏÖ®ÏäµÎãàÎã§.`
                                : `${user.user_name}ÎãòÏù¥ ${dateNow}Ïóê Ìá¥Í∑ºÌïòÏÖ®ÏäµÎãàÎã§.`;

                        await sendSlackMessage('#Ï∂úÌá¥Í∑º', message);

                        return res.json({ message: 'Ï∂úÍ∑ºÏôÑÎ£å', windowClose: true });
                    } catch (err) {
                        console.error('gtw Database query error:', err);
                        return res.status(500).json({ refreshSuccess: false, error: 'gtw Database query error' });
                    }
                } catch (err) {
                    console.error('Database query error:', err);
                    return res.status(500).json({ refreshSuccess: false, error: 'Database query error' });
                }
            } else {
                return res.status(500).send('Error fetching user info');
            }
        } catch (err) {
            console.error('Database query error:', err);
            return res.json({ message: 'Database query error', windowClose: false });
        }
    } catch (error) {
        console.error('Error in /gtwCheck route:', error);
        return res.status(400).send('Invalid user ID');
    }
});

router.post('/interactions', express.urlencoded({ extended: true }), async (req, res) => {
    const date = moment().format('YYYY-MM-DD');

    const payload = JSON.parse(req.body.payload);

    const { type, user, actions } = payload;

    if (payload.type === 'block_actions' && payload.actions[0].action_id === 'open_modal') {
        // Î™®Îã¨ÏùÑ ÎùÑÏö∞Îäî Ìï®Ïàò Ìò∏Ï∂ú
        await openModal(payload.trigger_id);
    }

    if (payload.type === 'view_submission') {
        const { user, view } = payload;
        const userId = user.id;

        // Î™®Îã¨ÏóêÏÑú Ï†úÏ∂úÎêú Í∞íÎì§ Í∞ÄÏ†∏Ïò§Í∏∞
        const selectedOption = view.state.values.input_c.select_input.selected_option.value;
        const selectedDate = view.state.values.input_date.datepicker_input.selected_date;

        const userInfo = await client.users.info({ user: userId });
        if (userInfo.ok) {
            const userEmail = userInfo.user.profile.email;

            const user = await User.findByEmailAsync(userEmail);

            console.log('Selected Option:', selectedOption);
            console.log('Selected Date:', selectedDate);
            console.log('UserId:', userId);

            const vacation = await Vca.createAsync(userEmail, selectedOption, selectedDate);

            const message =
                selectedOption === 'half'
                    ? `${user.user_name}ÎãòÏù¥ ${selectedDate}Ïóê Î∞òÏ∞®Î•º ÏÇ¨Ïö©ÌïòÏÖ®ÏäµÎãàÎã§.`
                    : selectedOption === 'day'
                    ? `${user.user_name}ÎãòÏù¥ ${selectedDate}Ïóê Ïó∞Ï∞®Î•º ÏÇ¨Ïö©ÌïòÏÖ®ÏäµÎãàÎã§.`
                    : selectedOption === 'home'
                    ? `${user.user_name}ÎãòÏù¥ ${selectedDate}Ïóê Ïû¨ÌÉùÍ∑ºÎ¨¥Î•º ÏÇ¨Ïö©ÌïòÏÖ®ÏäµÎãàÎã§.`
                    : selectedOption === 'vacation'
                    ? `${user.user_name}ÎãòÏù¥ ${selectedDate}Ïóê Ìú¥Í∞ÄÎ•º ÏÇ¨Ïö©ÌïòÏÖ®ÏäµÎãàÎã§.`
                    : `${user.user_name}ÎãòÏù¥ ${selectedDate}Ïóê Ïïå Ïàò ÏóÜÎäî ÌôúÎèôÏùÑ ÌïòÏÖ®ÏäµÎãàÎã§.`;

            await sendSlackMessage('#Ï∂úÌá¥Í∑º', message);

            const calendar = google.calendar({ version: 'v3', auth: oAuth2Client });

            const event = {
                summary: `${user.user_name}ÎãòÏù¥ ${selectedOption} ÏÇ¨Ïö©.`,
                description: message,
                start: {
                    date: selectedDate,
                    timeZone: 'Asia/Seoul',
                },
                end: {
                    date: selectedDate,
                    timeZone: 'Asia/Seoul',
                },
            };

            calendar.events.insert(
                {
                    auth: oAuth2Client,
                    calendarId: process.env.GOOGLE_CALENDAR_ID, // 'ÎßÅÌÅ¨ÎπÑ Ìú¥Í∞Ä Ï∫òÎ¶∞Îçî'Ïùò IDÎ°ú ÍµêÏ≤¥ÌïòÏÑ∏Ïöî
                    resource: event,
                },
                (err, event) => {
                    if (err) {
                        console.log('There was an error contacting the Calendar service: ' + err);
                        return;
                    }
                    console.log('Event created: %s', event.htmlLink);
                }
            );
        }

        // ÌïÑÏöîÌïú Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ Î°úÏßÅ Ï∂îÍ∞Ä
        // Ïòà: DBÏóê Ï†ÄÏû•, Slack Î©îÏãúÏßÄ Î≥¥ÎÇ¥Í∏∞ Îì±

        return res.status(200).json({ response_action: 'clear' });
    }

    res.status(200).send();
    //console.log(actions);
});

module.exports = router;
